Index: main.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#define STB_IMAGE_IMPLEMENTATION\n#include \"stb_image.h\"\n#include <GL/glut.h>\n#include <AntTweakBar.h>\n#include <assimp/Importer.hpp>\n#include <assimp/scene.h>\n#include <assimp/postprocess.h>\n#include <iostream>\n#include <vector>\n#include <cfloat>\n#include <string>\n\n// Camera parameters\nfloat cameraAngleX = 0.0f;\nfloat cameraAngleY = 0.0f;\nfloat cameraDistance = 5.0f;\nfloat cameraPosX = 0.0f;\nfloat cameraPosY = 0.0f;\n\n// Model data\nconst aiScene* scene = nullptr;\nAssimp::Importer importer;\nstd::string modelPath = \"C:\\\\Users\\\\hp\\\\Downloads\\\\Drone.obj\";\n\n// Texture variables\nGLuint textureID;\nstd::string texturePath = \"C:\\\\Users\\\\hp\\\\Downloads\\\\bmetal.jpg\";\n\n// Material properties\nfloat materialColor[3] = {0.8f, 0.8f, 0.8f}; // RGB color\nfloat materialShininess = 50.0f;  // Default shininess value\n\n// Light sources (directional and point lights)\nbool lightEnabled[3] = {true, true, false}; // Light 0 and 1 are enabled by default, Light 2 is disabled\nfloat lightPosition[3][4] = {{1.0f, 1.0f, 1.0f, 0.0f},   // Directional light\n                             {2.0f, 2.0f, 0.0f, 1.0f},   // Point light 1\n                             {-2.0f, -2.0f, 0.0f, 1.0f}}; // Point light 2\nfloat lightColor[3][3] = {{1.0f, 1.0f, 1.0f}, // Light 0 color (white)\n                          {1.0f, 0.5f, 0.0f}, // Light 1 color (orange)\n                          {0.0f, 0.0f, 1.0f}}; // Light 2 color (blue)\n\n// AntTweakBar handle\nTwBar* tweakBar;\n\n\n// Mouse state tracking variables\nbool isDragging = false;\nint lastMouseX = 0;\nint lastMouseY = 0;\n\nbool showCollisionHighlights = true;\n\n// Function prototypes\nvoid toggleCollisionHighlights();\nbool checkCollision(const aiMesh* mesh1, const aiMesh* mesh2);\nvoid drawCollisionHighlight(const aiMesh* mesh);\n\n\nint selectedObjectIndex = -1; // No object selected by default\nbool animateSelectedObject = false;\nfloat animationAngle = 0.0f; // Rotation angle\nconst float animationSpeed = 2.0f; // Speed of rotation (degrees per frame)\n\n\nvoid renderSelectedObject(const aiMesh* mesh) {\n    glPushMatrix();\n\n    // Rotate around the object's center\n    if (animateSelectedObject) {\n        glRotatef(animationAngle, 0.0f, 1.0f, 0.0f);\n    }\n\n    glColor3f(0.5f, 0.8f, 1.0f); // Highlight color for the selected object\n    glBegin(GL_TRIANGLES);\n    for (unsigned int j = 0; j < mesh->mNumFaces; j++) {\n        aiFace face = mesh->mFaces[j];\n        for (unsigned int k = 0; k < face.mNumIndices; k++) {\n            unsigned int index = face.mIndices[k];\n            if (mesh->HasNormals()) {\n                aiVector3D normal = mesh->mNormals[index];\n                glNormal3f(normal.x, normal.y, normal.z);\n            }\n            if (mesh->HasTextureCoords(0)) {\n                aiVector3D texCoord = mesh->mTextureCoords[0][index];\n                glTexCoord2f(texCoord.x, texCoord.y);\n            }\n            aiVector3D vertex = mesh->mVertices[index];\n            glVertex3f(vertex.x, vertex.y, vertex.z);\n        }\n    }\n    glEnd();\n\n    glPopMatrix();\n}\n\n// Update animation angle\nvoid updateAnimation(int value) {\n    if (animateSelectedObject) {\n        animationAngle += animationSpeed;\n        if (animationAngle >= 360.0f) {\n            animationAngle -= 360.0f; // Keep the angle within [0, 360]\n        }\n    }\n    glutPostRedisplay(); // Request a redraw\n    glutTimerFunc(16, updateAnimation, 0); // ~60 FPS (16 ms interval)\n}\n\n// Function to toggle object selection\nvoid toggleObjectSelection(int objectIndex) {\n    if (selectedObjectIndex == objectIndex) {\n        selectedObjectIndex = -1; // Deselect\n    } else {\n        selectedObjectIndex = objectIndex; // Select object\n    }\n    glutPostRedisplay();\n}\n\n// Function to render and animate a selected object\n\n// Helper function to calculate bounding boxes\nvoid calculateBoundingBox(const aiMesh* mesh, aiVector3D& min, aiVector3D& max) {\n    min = aiVector3D(FLT_MAX, FLT_MAX, FLT_MAX);\n    max = aiVector3D(-FLT_MAX, -FLT_MAX, -FLT_MAX);\n\n    for (unsigned int i = 0; i < mesh->mNumVertices; ++i) {\n        aiVector3D vertex = mesh->mVertices[i];\n        min.x = std::min(min.x, vertex.x);\n        min.y = std::min(min.y, vertex.y);\n        min.z = std::min(min.z, vertex.z);\n        max.x = std::max(max.x, vertex.x);\n        max.y = std::max(max.y, vertex.y);\n        max.z = std::max(max.z, vertex.z);\n    }\n}\n\n// Collision detection\nbool checkCollision(const aiMesh* mesh1, const aiMesh* mesh2) {\n    aiVector3D min1, max1, min2, max2;\n    calculateBoundingBox(mesh1, min1, max1);\n    calculateBoundingBox(mesh2, min2, max2);\n\n    return (min1.x <= max2.x && max1.x >= min2.x) &&\n           (min1.y <= max2.y && max1.y >= min2.y) &&\n           (min1.z <= max2.z && max1.z >= min2.z);\n}\n\n// Toggle collision highlights\nvoid toggleCollisionHighlights() {\n    showCollisionHighlights = !showCollisionHighlights;\n    glutPostRedisplay();\n}\n\n// Render collision highlights\nvoid drawCollisionHighlight(const aiMesh* mesh) {\n    glColor3f(1.0f, 0.0f, 0.0f);\n    glLineWidth(2.0f);\n\n    glBegin(GL_LINES);\n    for (unsigned int i = 0; i < mesh->mNumFaces; ++i) {\n        aiFace face = mesh->mFaces[i];\n        for (unsigned int j = 0; j < face.mNumIndices; ++j) {\n            unsigned int index1 = face.mIndices[j];\n            unsigned int index2 = face.mIndices[(j + 1) % face.mNumIndices];\n\n            aiVector3D vertex1 = mesh->mVertices[index1];\n            aiVector3D vertex2 = mesh->mVertices[index2];\n\n            glVertex3f(vertex1.x, vertex1.y, vertex1.z);\n            glVertex3f(vertex2.x, vertex2.y, vertex2.z);\n        }\n    }\n    glEnd();\n}\n\n// Function to load the model and calculate bounding box\nfloat calculateInitialDistance(const aiScene* scene) {\n    aiVector3D min(FLT_MAX, FLT_MAX, FLT_MAX);\n    aiVector3D max(-FLT_MAX, -FLT_MAX, -FLT_MAX);\n\n    for (unsigned int i = 0; i < scene->mNumMeshes; ++i) {\n        aiMesh* mesh = scene->mMeshes[i];\n        for (unsigned int j = 0; j < mesh->mNumVertices; ++j) {\n            aiVector3D vertex = mesh->mVertices[j];\n            min.x = std::min(min.x, vertex.x);\n            min.y = std::min(min.y, vertex.y);\n            min.z = std::min(min.z, vertex.z);\n            max.x = std::max(max.x, vertex.x);\n            max.y = std::max(max.y, vertex.y);\n            max.z = std::max(max.z, vertex.z);\n        }\n    }\n\n    aiVector3D size = max - min;\n    return std::max({size.x, size.y, size.z}) * 2.0f; // Set distance based on model size\n}\n\nvoid loadModel(const std::string& path) {\n    scene = importer.ReadFile(path, aiProcess_Triangulate | aiProcess_FlipUVs | aiProcess_JoinIdenticalVertices);\n    if (!scene || scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE || !scene->mRootNode) {\n        std::cerr << \"Error loading model: \" << importer.GetErrorString() << std::endl;\n        exit(EXIT_FAILURE);\n    }\n    std::cout << \"Model loaded successfully: \" << path << std::endl;\n    cameraDistance = calculateInitialDistance(scene); // Adjust camera distance\n}\n\n// Function to load a texture using stb_image\nGLuint loadTexture(const std::string& path) {\n    int width, height, channels;\n    unsigned char* data = stbi_load(path.c_str(), &width, &height, &channels, 0);\n    if (!data) {\n        std::cerr << \"Failed to load texture: \" << path << std::endl;\n        exit(EXIT_FAILURE);\n    }\n\n    GLuint texID;\n    glGenTextures(1, &texID);\n    glBindTexture(GL_TEXTURE_2D, texID);\n\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, (channels == 4 ? GL_RGBA : GL_RGB), GL_UNSIGNED_BYTE, data);\n\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n    stbi_image_free(data);\n    return texID;\n}\n\n\n// Updated renderNode function to apply textures\nvoid renderNode(const aiNode* node, const aiScene* scene, int nodeIndex = 0) {\n    for (unsigned int i = 0; i < node->mNumMeshes; i++) {\n        aiMesh* mesh = scene->mMeshes[node->mMeshes[i]];\n\n        // Render selected object in isolation\n        if (selectedObjectIndex == nodeIndex) {\n            renderSelectedObject(mesh);\n        } else if (selectedObjectIndex == -1) { // Render all objects if no selection\n            glColor3f(materialColor[0], materialColor[1], materialColor[2]);\n\n            glEnable(GL_TEXTURE_2D); // Enable texturing\n            glBindTexture(GL_TEXTURE_2D, textureID);\n\n            glBegin(GL_TRIANGLES);\n            for (unsigned int j = 0; j < mesh->mNumFaces; j++) {\n                aiFace face = mesh->mFaces[j];\n                for (unsigned int k = 0; k < face.mNumIndices; k++) {\n                    unsigned int index = face.mIndices[k];\n                    if (mesh->HasNormals()) {\n                        aiVector3D normal = mesh->mNormals[index];\n                        glNormal3f(normal.x, normal.y, normal.z);\n                    }\n                    if (mesh->HasTextureCoords(0)) {\n                        aiVector3D texCoord = mesh->mTextureCoords[0][index];\n                        glTexCoord2f(texCoord.x, texCoord.y);\n                    }\n                    aiVector3D vertex = mesh->mVertices[index];\n                    glVertex3f(vertex.x, vertex.y, vertex.z);\n                }\n            }\n            glEnd();\n\n            glDisable(GL_TEXTURE_2D); // Disable texturing after use\n\n            // Highlight collisions\n            if (showCollisionHighlights) {\n                for (unsigned int j = 0; j < scene->mNumMeshes; ++j) {\n                    if (mesh != scene->mMeshes[j] && checkCollision(mesh, scene->mMeshes[j])) {\n                        drawCollisionHighlight(mesh);\n                    }\n                }\n            }\n        }\n    }\n\n    for (unsigned int i = 0; i < node->mNumChildren; i++) {\n        renderNode(node->mChildren[i], scene, i);\n    }\n}\n\n\n// Initialize OpenGL settings\nvoid initOpenGL() {\n    glEnable(GL_DEPTH_TEST);\n    glEnable(GL_LIGHTING);\n    glEnable(GL_COLOR_MATERIAL);\n\n    GLfloat materialSpecular[] = {1.0f, 1.0f, 1.0f, 1.0f};\n    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, materialSpecular);\n\n    // Load texture\n    textureID = loadTexture(texturePath);\n}\n\n// Initialize AntTweakBar\nvoid initTweakBar() {\n    TwInit(TW_OPENGL, nullptr);\n    tweakBar = TwNewBar(\"Material and Lighting\");\n\n    // Material properties\n    TwAddVarRW(tweakBar, \"Color\", TW_TYPE_COLOR3F, &materialColor, \" label='Material Color' \");\n    TwAddVarRW(tweakBar, \"Shininess\", TW_TYPE_FLOAT, &materialShininess, \" label='Material Shininess' min=0 max=128 step=1 \");\n\n    // Light controls\n    TwAddVarRW(tweakBar, \"Light 0\", TW_TYPE_BOOL32, &lightEnabled[0], \" label='Directional Light' \");\n    TwAddVarRW(tweakBar, \"Light 1\", TW_TYPE_BOOL32, &lightEnabled[1], \" label='Point Light 1' \");\n    TwAddVarRW(tweakBar, \"Light 2\", TW_TYPE_BOOL32, &lightEnabled[2], \" label='Point Light 2' \");\n    TwAddVarRW(tweakBar, \"Highlight Collisions\", TW_TYPE_BOOL32, &showCollisionHighlights, \" label='Highlight Collisions' \");\n\n}\n\n// Set light properties\nvoid setLights() {\n    // Light 0 (Directional Light)\n    if (lightEnabled[0]) {\n        glEnable(GL_LIGHT0);\n        glLightfv(GL_LIGHT0, GL_POSITION, lightPosition[0]);\n        glLightfv(GL_LIGHT0, GL_DIFFUSE, lightColor[0]);\n    } else {\n        glDisable(GL_LIGHT0);\n    }\n\n    // Light 1 (Point Light 1)\n    if (lightEnabled[1]) {\n        glEnable(GL_LIGHT1);\n        glLightfv(GL_LIGHT1, GL_POSITION, lightPosition[1]);\n        glLightfv(GL_LIGHT1, GL_DIFFUSE, lightColor[1]);\n    } else {\n        glDisable(GL_LIGHT1);\n    }\n\n    // Light 2 (Point Light 2)\n    if (lightEnabled[2]) {\n        glEnable(GL_LIGHT2);\n        glLightfv(GL_LIGHT2, GL_POSITION, lightPosition[2]);\n        glLightfv(GL_LIGHT2, GL_DIFFUSE, lightColor[2]);\n    } else {\n        glDisable(GL_LIGHT2);\n    }\n}\n\n// Render scene\nvoid display() {\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    glLoadIdentity();\n\n    // Set camera position\n    glTranslatef(0.0f, 0.0f, -cameraDistance);\n    glRotatef(cameraAngleX, 1.0f, 0.0f, 0.0f);\n    glRotatef(cameraAngleY, 0.0f, 1.0f, 0.0f);\n    glTranslatef(-cameraPosX, -cameraPosY, 0.0f);\n\n    // Set lights\n    setLights();\n\n    // Update material properties based on the tweak bar values\n    GLfloat materialShininessValue[] = {materialShininess};\n    glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, materialShininessValue);\n\n    // Set the diffuse material color\n    glColor3f(materialColor[0], materialColor[1], materialColor[2]);\n\n    // Render the model\n    if (scene && scene->mRootNode) {\n        renderNode(scene->mRootNode, scene);\n    }\n\n    // Draw AntTweakBar\n    TwDraw();\n\n    glutSwapBuffers();\n}\n\n// Handle mouse motion for AntTweakBar and camera\nvoid mouseMotion(int x, int y) {\n    if (!TwEventMouseMotionGLUT(x, y) && isDragging) {\n        cameraAngleY += (x - lastMouseX) * 0.2f;\n        cameraAngleX += (y - lastMouseY) * 0.2f;\n        lastMouseX = x;\n        lastMouseY = y;\n        glutPostRedisplay();\n    }\n}\n\n// Handle mouse events\nvoid mouse(int button, int state, int x, int y) {\n    if (!TwEventMouseButtonGLUT(button, state, x, y)) {\n        if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN) {\n            isDragging = true;\n            lastMouseX = x;\n            lastMouseY = y;\n        } else if (button == GLUT_LEFT_BUTTON && state == GLUT_UP) {\n            isDragging = false;\n        } else if (button == GLUT_RIGHT_BUTTON) {\n            cameraDistance += (state == GLUT_DOWN) ? -0.5f : 0.5f;\n            if (cameraDistance < 1.0f) cameraDistance = 1.0f;\n            glutPostRedisplay();\n        }\n    }\n}\n\n// Handle keyboard inputs\nvoid keyboard(unsigned char key, int x, int y) {\n    if (!TwEventKeyboardGLUT(key, x, y)) {\n        switch (key) {\n            case 'w': cameraPosY += 0.1f; break;\n            case 's': cameraPosY -= 0.1f; break;\n            case 'a': cameraPosX -= 0.1f; break;\n            case 'd': cameraPosX += 0.1f; break;\n            case '1': // Select first object\n                toggleObjectSelection(0); // Select the first object\n                break;\n            case '2': // Select second object\n                toggleObjectSelection(1); // Select the second object\n                break;\n            case '3': // Select third object\n                toggleObjectSelection(2); // Select the third object\n                break;\n            case '4': // Select fourth object\n                toggleObjectSelection(3); // Select the fourth object\n                break;\n            case '5': // Select fifth object\n                toggleObjectSelection(4); // Select the fifth object\n                break;\n            case '6': // Select fourth object\n                toggleObjectSelection(5); // Select the fourth object\n                break;\n            case '7': // Select fifth object\n                toggleObjectSelection(6); // Select the fifth object\n                break;\n            case '8': // Select fifth object\n                toggleObjectSelection(7); // Select the fifth object\n                break;\n            case '9': // Select fifth object\n                toggleObjectSelection(8); // Select the fifth object\n                break;\n            case 'l': // Toggle animation\n                animateSelectedObject = !animateSelectedObject;\n                break;\n            case 'r': // Reset camera\n                cameraAngleX = 0.0f;\n                cameraAngleY = 0.0f;\n                cameraDistance = 5.0f;\n                cameraPosX = 0.0f;\n                cameraPosY = 0.0f;\n                break;\n            case 27: // Escape key\n                TwTerminate();\n                exit(0);\n        }\n        glutPostRedisplay();\n    }\n}\n\nvoid initAnimation() {\n    glutTimerFunc(16, updateAnimation, 0); // Start animation timer\n}\n\n// Handle window resize\nvoid reshape(int w, int h) {\n    glViewport(0, 0, w, h);\n    glMatrixMode(GL_PROJECTION);\n    glLoadIdentity();\n    gluPerspective(45.0, (double)w / (double)h, 1.0, 100.0);\n    glMatrixMode(GL_MODELVIEW);\n    TwWindowSize(w, h);\n}\n\nint main(int argc, char** argv) {\n    // Initialize GLUT\n    glutInit(&argc, argv);\n    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);\n    glutInitWindowSize(800, 600);\n    glutCreateWindow(\"3D Drone Viewer with Material Editor and Lights\");\n\n    // Initialize OpenGL\n    initOpenGL();\n\n    // Initialize AntTweakBar\n    initTweakBar();\n\n    // Load the drone model\n    loadModel(modelPath);\n\n    // Register callbacks\n    glutDisplayFunc(display);\n    glutReshapeFunc(reshape);\n    glutMouseFunc(mouse);\n    glutMotionFunc(mouseMotion);\n    glutKeyboardFunc(keyboard);\n\n    initAnimation();\n\n    // Start main loop\n    glutMainLoop();\n    TwTerminate();\n    return 0;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main.cpp b/main.cpp
--- a/main.cpp	(revision 7daee09c1d2bf3e96eeda8d9682b656e90a54e95)
+++ b/main.cpp	(date 1736957370529)
@@ -1,7 +1,6 @@
 #define STB_IMAGE_IMPLEMENTATION
-#include "stb_image.h"
 #include <GL/glut.h>
-#include <AntTweakBar.h>
+#include "bin/Debug/AntTweakBar.h"
 #include <assimp/Importer.hpp>
 #include <assimp/scene.h>
 #include <assimp/postprocess.h>
@@ -9,6 +8,7 @@
 #include <vector>
 #include <cfloat>
 #include <string>
+#include "bin/Debug/stb_image.h"
 
 // Camera parameters
 float cameraAngleX = 0.0f;
@@ -20,11 +20,11 @@
 // Model data
 const aiScene* scene = nullptr;
 Assimp::Importer importer;
-std::string modelPath = "C:\\Users\\hp\\Downloads\\Drone.obj";
+std::string modelPath = "/home/bakr/D.rone.obj";
 
 // Texture variables
 GLuint textureID;
-std::string texturePath = "C:\\Users\\hp\\Downloads\\bmetal.jpg";
+std::string texturePath = "/home/bakr/Downloads/bmetal.jpg";
 
 // Material properties
 float materialColor[3] = {0.8f, 0.8f, 0.8f}; // RGB color
